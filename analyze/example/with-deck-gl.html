<!DOCTYPE html>
<html>
  <head>
    <title>MapLibre GL JS and LAS Data Example</title>
    <script src="http://127.0.0.1:9966/dist/maplibre-gl-dev.js"></script>
    <link href="../../dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/deck.gl@8.9.29/dist.min.js"></script>
    <script src="https://unpkg.com/@loaders.gl/las@^3.4.14/dist/dist.min.js"></script>
    <script src="https://unpkg.com/browse/@loaders.gl/core@3.4.14/dist/dist.min.js"></script>
    <script src="https://unpkg.com/@luma.gl/constants@8.5.21/dist/dist.min.js"></script>

    <style>
      #map {
        position: absolute;
        top: 0;
        bottom: 0;
        width: 100%;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <script>
      const { MapboxLayer, Layer, PointCloudLayer, COORDINATE_SYSTEM } = deck;
      const { LASLoader, load, registerLoaders } = loaders;
      const { Model, GL } = luma;

      class OctreeNode {
        constructor(min, max) {
          this.min = min;
          this.max = max;
          this.points = [];
          this.children = null;
        }

        addPoint(point, maxDepth, currentDepth = 0) {
          if (currentDepth >= maxDepth) {
            this.points.push(point);
            return;
          }

          if (this.children === null) {
            this.subdivide();
          }
          const childIndex = this.getChildIndex(point);
          this.children[childIndex].addPoint(point, maxDepth, currentDepth + 1);
        }
        getChildIndex(point) {
          const { min, max } = this;
          const midX = (min[0] + max[0]) / 2;
          const midY = (min[1] + max[1]) / 2;
          const midZ = (min[2] + max[2]) / 2;

          let index = 0;
          if (point[0] > midX) index |= 1;
          if (point[1] > midY) index |= 2;
          if (point[2] > midZ) index |= 4;

          return index;
        }

        subdivide() {
          const { min, max } = this;
          const midX = (min[0] + max[0]) / 2;
          const midY = (min[1] + max[1]) / 2;
          const midZ = (min[2] + max[2]) / 2;

          this.children = [
            new OctreeNode(min, [midX, midY, midZ]),
            new OctreeNode([midX, min[1], min[2]], [max[0], midY, midZ]),
            new OctreeNode([min[0], midY, min[2]], [midX, max[1], midZ]),
            new OctreeNode([midX, midY, min[2]], [max[0], max[1], midZ]),
            new OctreeNode([min[0], min[1], midZ], [midX, midY, max[2]]),
            new OctreeNode([midX, min[1], midZ], [max[0], midY, max[2]]),
            new OctreeNode([min[0], midY, midZ], [midX, max[1], max[2]]),
            new OctreeNode([midX, midY, midZ], max),
          ];
        }
      }

      class Octree {
        constructor(min, max, maxDepth = 8) {
          this.root = new OctreeNode(min, max);
          this.maxDepth = maxDepth;
        }

        addPoint(point) {
          this.root.addPoint(point, this.maxDepth);
        }

        _addPoint(node, point, depth) {
          if (depth === this.maxDepth) {
            node.addPoint(point);
            return;
          }
          if (node.children === null) {
            node.subdivide();
          }

          const childIndex = this.getChildIndex(node, point);
          this._addPoint(node.children[childIndex], point, depth + 1);
        }

        getChildIndex(node, point) {
          const { min, max } = node;
          const midX = (min[0] + max[0]) / 2;
          const midY = (min[1] + max[1]) / 2;
          const midZ = (min[2] + max[2]) / 2;

          const xIndex = point[0] > midX ? 1 : 0;
          const yIndex = point[1] > midY ? 1 : 0;
          const zIndex = point[2] > midZ ? 1 : 0;

          return xIndex * 4 + yIndex * 2 + zIndex;
        }

        getVisibleNodes(viewport) {
          const nodes = [];
          this._getVisibleNodes(this.root, viewport, nodes);
          return nodes;
        }

        _getVisibleNodes(node, viewport, nodes) {
          if (boxIntersectsBox(node.min, node.max, viewport.min, viewport.max)) {
            nodes.push(node);
            if (node.children !== null) {
              for (const child of node.children) {
                this._getVisibleNodes(child, viewport, nodes);
              }
            }
          }
        }

        getPointsInNodes(nodes) {
          const points = [];
          for (const node of nodes) {
            points.push(...node.points);
          }
          return points;
        }
      }

      function boxIntersectsBox(min1, max1, min2, max2) {
        for (let i = 0; i < 3; i++) {
          if (max1[i] < min2[i] || min1[i] > max2[i]) {
            return false;
          }
        }
        return true;
      }

      function pointInBox(point, box) {
        for (let i = 0; i < 3; i++) {
          if (point[i] < box.min[i] || point[i] > box.max[i]) {
            return false;
          }
        }
        return true;
      }

      /** An absolutely minimal primitive layer */
      const vs = `\
#define SHADER_NAME point-cloud-layer-vertex-shader

attribute vec4 instanceColors;
attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;

uniform float opacity;
uniform float pointSize;

varying vec4 vColor;

void main(void) {
  vec3 positionCommon = project_position(instancePositions, instancePositions64Low);
  gl_Position = project_common_position_to_clipspace(vec4(positionCommon, 1.0));
  gl_PointSize = pointSize;
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);
}
`;

      const fs = `\
#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;
}
`;

        // 데이터를 작은 청크로 나누어 처리
        async function updateOctreeInChunks(data, octree, chunkSize = 1000) {
          let i = 0;
          while (i < data.length) {
            const chunkEnd = Math.min(i + chunkSize, data.length);
            for (; i < chunkEnd; i++) {
              const x = data.attributes.getPosition.value[i * 3];
              const y = data.attributes.getPosition.value[i * 3 + 1];
              const z = data.attributes.getPosition.value[i * 3 + 2];
              const position = [x, y, z];
              octree.addPoint(position);
            }
            await new Promise(resolve => setTimeout(resolve, 0));  // 이벤트 루프를 언블록
          }
        }

      class MyPointCloudLayer extends Layer {
        static layerName = 'PointCloudLayer';
        static defaultProps = {
          pointSize: { type: 'number', min: 0 },
          getPosition: { type: 'accessor', value: (x) => x.position },
          getColor: { type: 'accessor', value: [0, 0, 0, 255] },
        };

        initializeState() {
          this.getAttributeManager().addInstanced({
            instancePositions: {
              size: 3,
              type: GL.DOUBLE,
              accessor: 'getPosition',
            },
            instanceColors: {
              size: 4,
              type: GL.UNSIGNED_BYTE,
              normalized: true,
              accessor: 'getColor',
              defaultValue: [0, 0, 0, 255],
            },
          });
          this.octree = new Octree([-10000, -10000, -10000], [10000, 10000, 10000]);

          this.state.model = this._getModel(this.context.gl);
        }



        updateState({ props, oldProps, changeFlags }) {
          if (changeFlags.dataChanged) {
            updateOctreeInChunks(props.data, this.octree);
          }
        }

        draw({ uniforms }) {
          const { pointSize } = this.props;

          // 시야 내의 옥트리 노드와 해당 노드에 속한 포인트 검색
          // Compute the visible nodes and points here.
          const viewport = { min: [-1000, -1000, -1000], max: [1000, 1000, 1000] }; // Placeholder
          const visibleNodes = this.octree.getVisibleNodes(viewport);
          const visiblePoints = this.octree.getPointsInNodes(visibleNodes);

          // 여기서 visiblePoints를 이용해 instancePositions 속성을 업데이트
          const instancePositions = new Float64Array(visiblePoints.length * 3);
          for (let i = 0; i < visiblePoints.length; ++i) {
            instancePositions.set(visiblePoints[i], i * 3);
          }

          this.getAttributeManager().update({
            attributes: {
              instancePositions: instancePositions,
            },
          });

          this.state.model
            .setUniforms(uniforms)
            .setUniforms({
              pointSize,
            })
            .draw();
        }

        _getModel(gl) {
          return new Model(gl, {
            id: this.props.id,
            vs,
            fs,
            drawMode: GL.POINTS,
            vertexCount: 1,
            instanced: true,
          });
        }
      }

      registerLoaders(LASLoader);

      const LAS_SAMPLE = '../data/output_127.1068385-37.4021746.las';

      let pointData = null;

      function convertLoadersMeshToDeckPointCloudData(vertexCount, attributes) {
        const pointFloat64Array = new Float64Array(vertexCount * 3);
        const originalArray = new Int8Array(vertexCount * 3);
        for (let i = 0; i < vertexCount; i++) {
          const intensity = attributes.intensity.value[i];
          originalArray[i * 3] = intensity;
          originalArray[i * 3 + 1] = intensity;
          originalArray[i * 3 + 2] = intensity;
          pointFloat64Array[i * 3] = attributes.POSITION.value[i * 3];
          pointFloat64Array[i * 3 + 1] = attributes.POSITION.value[i * 3 + 1];
          pointFloat64Array[i * 3 + 2] = attributes.POSITION.value[i * 3 + 2];
        }

        const deckAttributes = {};
        deckAttributes.getColor = { size: 3, value: originalArray };
        deckAttributes.getPosition = attributes.POSITION;
        //deckAttributes.getPosition = {size:3,value:pointFloat64Array};
        //deckAttributes.getNormal = {value: [0, 0, 1], constant: true}
        // Check PointCloudLayer docs for other supported props?
        return {
          length: attributes.POSITION.value.length / attributes.POSITION.size,
          attributes: deckAttributes,
        };
      }

      function _onLoad({ header, loaderData, attributes, progress }) {
        console.log(header);

        if (pointData == null) {
          pointData = convertLoadersMeshToDeckPointCloudData(header.vertexCount, attributes);

          let ply_pointcloud = new MapboxLayer({
            id: 'deckgl-PointCloudLayer',
            type: PointCloudLayer,
            data: pointData,
            coordinateOrigin: [127.1068385, 37.4021746, -19],
            coordinateSystem: COORDINATE_SYSTEM.METER_OFFSETS,
            opacity: 0.8,
            loaders: [LASLoader],
            pointSize: 1,
            material: false,
          });

          map.addLayer(ply_pointcloud);
          map.showTileBoundaries = false;
        }

        console.log('loaded');
      }

      // Initialize MapLibre GL JS map
      let hoveredStateId = null;
      const map = new maplibregl.Map({
        container: 'map',
        zoom: 18,
        center: [127.1104411, 37.4020702],
        pitch: 52,
        hash: true,
        style: {
          version: 8,
          sources: {
            osm: {
              type: 'raster',
              tiles: [
                'http://61.33.249.243:25004/maps/wmts?SERVICE=WMTS&REQUEST=GetTile&VERSION=1.0.0&LAYER=InaviSatellite&STYLE=default&FORMAT=image/png&TILEMATRIXSET=GoogleMapsCompatible&TILEMATRIX={z}&TILEROW={y}&TILECOL={x}',
              ],
              tileSize: 256,
              maxzoom: 17,
            },
            // Use a different source for terrain and hillshade layers, to improve render quality
            terrainSource: {
              type: 'raster-dem',
              url: 'http://10.10.82.42:24003/mapbox_mvt/2304/tile.json',
              tileSize: 256,
            },
            hillshadeSource: {
              type: 'raster-dem',
              url: 'http://10.10.82.42:24003/mapbox_mvt/2304/tile.json',
              tileSize: 256,
            },
          },
          layers: [
            {
              id: 'osm',
              type: 'raster',
              source: 'osm',
            },
          ],
          terrain: {
            source: 'terrainSource',
            exaggeration: 1,
          },
        },
        maxZoom: 25,
        maxPitch: 85,
      });

      map.on('load', function () {
        map.showTileBoundaries = true;

        load(LAS_SAMPLE).then(_onLoad.bind(this));
      });
    </script>
  </body>
</html>
